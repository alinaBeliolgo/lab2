# lab2
Индивидуальная работа по JS№2

Цель работы
Ознакомить студентов с продвинутыми функциями JavaScript, включая асинхронный JavaScript, модули и обработку ошибок.



Контрольные вопросы
1. Какое значение возвращает функция fetch?_
2. Что представляет собой Promise?_
3. Какие методы доступны у объекта Promise?_
4. Каковы основные различия между использованием async / await и Promise?_

1. Функция fetch возвращает объект Promise, который представляет собой обещание (promise) о том, что будет получен ответ (response) от сервера после выполнения запроса.
2. Promise представляет собой механизм в JavaScript для работы с асинхронными операциями. Он обещает выполнить определенную операцию асинхронно и предоставить результат в будущем, либо сообщить об ошибке, если операция не выполнена успешно. Promise может находиться в одном из трех состояний:
pending (в ожидании): начальное состояние, операция ещё не завершена.
fulfilled (выполнено): операция успешно завершилась, Promise содержит результат.
rejected (отклонено): операция завершилась неудачей, Promise содержит причину отказа.
3. У объекта Promise доступны следующие методы:
  3.1 then: Этот метод используется для регистрации обратных вызовов (callbacks) для успешного завершения (fulfillment) или неудачи (rejection) операции. Вызывается с двумя функциями: первая функция вызывается при успешном завершении, вторая — при неудаче.
  3.2 catch: Используется для регистрации обратного вызова для обработки ошибок (reject) промиса.
  3.3 finally: Выполняется после того, как Promise завершился, независимо от того, завершился он успешно или неудачно.
  3.4 all: Метод, который позволяет ожидать завершения всех переданных промисов и возвращает новый промис, который разрешается, когда все промисы завершены.
  3.5 race: Принимает массив промисов и возвращает новый промис, который разрешается или отклоняется, когда первый из переданных промисов завершится.
4. Основные различия между использованием async/await и Promise:
   4.1 async / await является синтаксическим сахаром для работы с промисами. Оно позволяет писать асинхронный код в более понятном и линейном стиле, который похож на синхронный код.
   4.2 При использовании Promise, код часто представляет собой вложенные цепочки методов then, что может привести к менее читаемому коду.
   4.3 async / await автоматически обрабатывает обещания и ошибки, что делает код более чистым и более легким для понимания.
   4.4 async / await позволяет обрабатывать ошибки с помощью конструкции try...catch, тогда как в случае использования Promise, ошибки должны быть обработаны с помощью метода catch.
   4.5 async / await облегчает управление последовательными и параллельными операциями, в то время как с Promise это может потребовать дополнительного кода для достижения аналогичных результатов




//index.js

import { getRandomActivity } from './activity.js';
function updateActivity(activity) {
    getRandomActivity().then(activity => {
        document.getElementById("activity").textContent = activity;
    }).catch (console.log("Error"));
setTimeout(updateActivity, 5000);


Мы добавили импорт функции getRandomActivity из модуля activity.js, чтобы использовать её в текущем файле. Функция updateActivity была изменена, чтобы использовать Promise с методами then() и catch(). Теперь она вызывает getRandomActivity(), а затем обновляет текст элемента с id "activity" на странице с полученной активностью.
Мы использовали setTimeout, чтобы установить таймер на 5 секунд, после чего будет вызвана функция updateActivity(). Это позволяет обновлять активность на странице каждые 5 секунд. В результате этих изменений код будет обновлять активность на странице каждые 5 секунд, используя функцию getRandomActivity() из модуля activity.js, и выводить ошибки в консоль в случае их возникновения.


//activity.js
// Шаг 1: Напишите функцию getRandomActivity(), которая будет делать запрос и получать данные со стороннего ресурса.
export function getRandomActivity() {
    fetch('https://www.boredapi.com/api/activity/')
        .then(response => response.json())
        .then(data => {
            updateActivity(data.activity);
        })
        .catch(error => {
            const activityElement = document.getElementById('activity');
            activityElement.textContent = "К сожалению, произошла ошибка";
        });
}
/*Мы создали функцию getRandomActivity(), которая использует fetch для отправки запроса на сторонний ресурс и получения данных о случайной активности. Если запрос успешен, мы обновляем активность на странице. Если возникает ошибка, мы выводим сообщение об ошибке.*/


// Шаг 2: Отобразите полученную активность на странице index.html.
function updateActivity(activityText) {
    const activityElement = document.getElementById('activity');
    activityElement.textContent = activityText;
}
/*Здесь мы определяем функцию updateActivity(), которая обновляет текст активности на HTML-странице. Она принимает текст активности в качестве аргумента и затем находит элемент с id "activity" на странице и устанавливает его текст равным переданному значению.*/

// Шаг 3: Добавьте обработку ошибок в функцию getRandomActivity().
.catch(error => {
    const activityElement = document.getElementById('activity');
    activityElement.textContent = "К сожалению, произошла ошибка";
});

/*Здесь мы добавляем блок .catch(), чтобы обработать любые ошибки, возникающие при выполнении запроса. Если возникает ошибка, мы изменяем текст элемента с id "activity" на странице, чтобы сообщить пользователю о проблеме.*/


// Шаг 4 и 5: Измените функцию getRandomActivity() так, чтобы она использовала ключевые слова async/await и добавьте функционал обновления данных каждую минуту.

export async function getRandomActivity() {
    try {
        const response = await fetch('https://www.boredapi.com/api/activity/');
        const data = await response.json();
        updateActivity(data.activity);
    } catch (error) {
        const activityElement = document.getElementById('activity');
        activityElement.textContent = "К сожалению, произошла ошибка";
    } finally {
        setTimeout(getRandomActivity, 5000);
    }
}

/*Здесь мы преобразуем функцию getRandomActivity() в асинхронную, чтобы использовать ключевое слово await при выполнении запроса. Мы также добавляем блок try/catch для обработки ошибок. Используя блок finally, мы вызываем setTimeout, чтобы функция getRandomActivity() выполнялась в заданный промежуток времени.(я уменьшила время до 5 секунд, чтобы увидеть результат быстрее)*/



//Шаг 6: Дополнительное задание: измените функцию getRandomActivity() так, чтобы она возвращала данные, и добавьте функцию updateActivity(), которая будет отображать полученные данные.

export async function getRandomActivity() {
    try {
        const response = await fetch('https://www.boredapi.com/api/activity/');
        const data = await response.json();
        return data.activity;
    } catch (error) {
        return "К сожалению, произошла ошибка";
    }
}

function updateActivity(activityText) {
    const activityElement = document.getElementById('activity');
    activityElement.textContent = activityText;
}

async function displayRandomActivity() {
    const activity = await getRandomActivity();
    updateActivity(activity);
}

displayRandomActivity(); 
setInterval(displayRandomActivity, 5000); 

/*В этом шаге мы переписали функцию getRandomActivity() так, чтобы она возвращала активность вместо непосредственного обновления элемента DOM. Затем мы создали функцию displayRandomActivity(), которая вызывает getRandomActivity() и использует полученную активность для обновления элемента на странице. Мы вызываем displayRandomActivity() один раз при загрузке страницы и затем используем setInterval, чтобы обновлять в заданное время.*/


Вывод:
В данной лабораторной работе мы познакомились с продвинутыми функциями JavaScript, включая асинхронный JavaScript, модули и обработку ошибок. Мы начали с написания функции для получения случайной активности с внешнего ресурса, используя fetch для отправки запроса и получения данных. Затем мы отобразили полученную активность на веб-странице, обновляя соответствующий HTML-элемент. Добавив обработку ошибок, мы обеспечили более устойчивое поведение при возникновении проблем с запросом. Затем мы улучшили код, используя асинхронные функции и await/async для более чистого и понятного синтаксиса. Наконец, мы добавили функционал автоматического обновления данных каждую минуту с использованием setTimeout. Эти навыки могут быть полезны во многих веб-проектах, где требуется взаимодействие с внешними API, асинхронная загрузка данных и обработка возможных ошибок для обеспечения лучшего пользовательского опыта.



Библиография:
https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise
https://doka.guide/js/promise/
